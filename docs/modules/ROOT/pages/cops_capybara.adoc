////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= Capybara

[#capybaraambiguousclick]
== Capybara/AmbiguousClick

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| <<next>>
| -
|===

Specify the exact target to click on.

In projects where accessibility needs to be considered,
it is crucial to specify the click target precisely.

[#examples-capybaraambiguousclick]
=== Examples

[source,ruby]
----
# bad
click_link_or_button('foo')
click_on('foo')

# good
click_link('foo')
click_button('foo')
----

[#references-capybaraambiguousclick]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/AmbiguousClick

[#capybaraclicklinkorbuttonstyle]
== Capybara/ClickLinkOrButtonStyle

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 2.19
| <<next>>
|===

Checks for methods of button or link clicks.

This cop is deprecated.
We plan to remove this in the next major version update to 3.0.

The migration target is `Capybara/AmbiguousClick`.
It is only migration target when `EnforcedStyle: strict`.
If you are using this cop, please plan for migration.
There is no migration target when `EnforcedStyle: link_or_button`.

By default, prefer to use `click_link_or_button` or `click_on`.
These methods offer a weaker coupling between the test and HTML,
allowing for a more faithful reflection of how the user behaves.

You can set `EnforcedStyle: strict` to prefer the use of
`click_link` and `click_button`, but this is a deprecated setting.

[#examples-capybaraclicklinkorbuttonstyle]
=== Examples

[#enforcedstyle_-link_or_button-_default_-capybaraclicklinkorbuttonstyle]
==== EnforcedStyle: link_or_button (default)

[source,ruby]
----
# bad
click_link('foo')
click_button('foo')

# good
click_link_or_button('foo')
click_on('foo')
----

[#enforcedstyle_-strict-capybaraclicklinkorbuttonstyle]
==== EnforcedStyle: strict

[source,ruby]
----
# bad
click_link_or_button('foo')
click_on('foo')

# good
click_link('foo')
click_button('foo')
----

[#configurable-attributes-capybaraclicklinkorbuttonstyle]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `link_or_button`
| `link_or_button`, `strict`
|===

[#references-capybaraclicklinkorbuttonstyle]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/ClickLinkOrButtonStyle

[#capybaracurrentpathexpectation]
== Capybara/CurrentPathExpectation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 1.18
| 2.0
|===

Checks that no expectations are set on Capybara's `current_path`.

The
https://www.rubydoc.info/github/teamcapybara/capybara/master/Capybara/RSpecMatchers#have_current_path-instance_method[`have_current_path` matcher]
should be used on `page` to set expectations on Capybara's
current path, since it uses
https://github.com/teamcapybara/capybara/blob/master/README.md#asynchronous-javascript-ajax-and-friends[Capybara's waiting functionality]
which ensures that preceding actions (like `click_link`) have
completed.

This cop does not support autocorrection in some cases.

[#examples-capybaracurrentpathexpectation]
=== Examples

[source,ruby]
----
# bad
expect(current_path).to eq('/callback')
expect(page.current_path).to eq('/callback')

# good
expect(page).to have_current_path('/callback', ignore_query: true)

# bad (does not support autocorrection when `match` with a variable)
expect(page).to match(variable)
----

[#references-capybaracurrentpathexpectation]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/CurrentPathExpectation

[#capybarafindallfirst]
== Capybara/FindAllFirst

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| <<next>>
| -
|===

Enforces use of `first` instead of `all` with `first` or `[0]`.

[#examples-capybarafindallfirst]
=== Examples

[source,ruby]
----
# bad
all('a').first
all('a')[0]
find('a', match: :first)
all('a', match: :first)

# good
first('a')
----

[#references-capybarafindallfirst]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/FindAllFirst

[#capybaramatchstyle]
== Capybara/MatchStyle

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 2.17
| -
|===

Checks for usage of deprecated style methods.

[#examples-capybaramatchstyle]
=== Examples

[#when-using-_assert_style_-capybaramatchstyle]
==== when using `assert_style`

[source,ruby]
----
# bad
page.find(:css, '#first').assert_style(display: 'block')

# good
page.find(:css, '#first').assert_matches_style(display: 'block')
----

[#when-using-_has_style__-capybaramatchstyle]
==== when using `has_style?`

[source,ruby]
----
# bad
expect(page.find(:css, 'first')
  .has_style?(display: 'block')).to be true

# good
expect(page.find(:css, 'first')
  .matches_style?(display: 'block')).to be true
----

[#when-using-_have_style_-capybaramatchstyle]
==== when using `have_style`

[source,ruby]
----
# bad
expect(page).to have_style(display: 'block')

# good
expect(page).to match_style(display: 'block')
----

[#references-capybaramatchstyle]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/MatchStyle

[#capybaranegationmatcher]
== Capybara/NegationMatcher

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 2.14
| 2.20
|===

Enforces use of `have_no_*` or `not_to` for negated expectations.

[#examples-capybaranegationmatcher]
=== Examples

[#enforcedstyle_-have_no-_default_-capybaranegationmatcher]
==== EnforcedStyle: have_no (default)

[source,ruby]
----
# bad
expect(page).not_to have_selector 'a'
expect(page).not_to have_css('a')

# good
expect(page).to have_no_selector 'a'
expect(page).to have_no_css('a')
----

[#enforcedstyle_-not_to-capybaranegationmatcher]
==== EnforcedStyle: not_to

[source,ruby]
----
# bad
expect(page).to have_no_selector 'a'
expect(page).to have_no_css('a')

# good
expect(page).not_to have_selector 'a'
expect(page).not_to have_css('a')
----

[#configurable-attributes-capybaranegationmatcher]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `have_no`
| `have_no`, `not_to`
|===

[#references-capybaranegationmatcher]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/NegationMatcher

[#capybaranegationmatcheraftervisit]
== Capybara/NegationMatcherAfterVisit

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| <<next>>
| -
|===

Do not allow negative matchers to be used immediately after `visit`.

[#examples-capybaranegationmatcheraftervisit]
=== Examples

[source,ruby]
----
# bad
visit foo_path
expect(page).to have_no_link('bar')
expect(page).to have_css('a')

# good
visit foo_path
expect(page).to have_css('a')
expect(page).to have_no_link('bar')

# bad
visit foo_path
expect(page).not_to have_link('bar')
expect(page).to have_css('a')

# good
visit foo_path
expect(page).to have_css('a')
expect(page).not_to have_link('bar')
----

[#references-capybaranegationmatcheraftervisit]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/NegationMatcherAfterVisit

[#capybararedundantwithinfind]
== Capybara/RedundantWithinFind

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 2.20
| -
|===

Checks for redundant `within find(...)` calls.

[#examples-capybararedundantwithinfind]
=== Examples

[source,ruby]
----
# bad
within find('foo.bar') do
  # ...
end

# good
within 'foo.bar' do
  # ...
end

# bad
within find_by_id('foo') do
  # ...
end

# good
within '#foo' do
  # ...
end
----

[#references-capybararedundantwithinfind]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/RedundantWithinFind

[#capybaraspecificactions]
== Capybara/SpecificActions

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 2.14
| -
|===

Checks for there is a more specific actions offered by Capybara.

[#examples-capybaraspecificactions]
=== Examples

[source,ruby]
----
# bad
find('a').click
find('button.cls').click
find('a', exact_text: 'foo').click
find('div button').click

# good
click_link
click_button(class: 'cls')
click_link(exact_text: 'foo')
find('div').click_button
----

[#references-capybaraspecificactions]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/SpecificActions

[#capybaraspecificfinders]
== Capybara/SpecificFinders

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 2.13
| -
|===

Checks if there is a more specific finder offered by Capybara.

[#examples-capybaraspecificfinders]
=== Examples

[source,ruby]
----
# bad
find('#some-id')
find('[id=some-id]')
find(:css, '#some-id')
find(:id, 'some-id')

# good
find_by_id('some-id')
----

[#references-capybaraspecificfinders]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/SpecificFinders

[#capybaraspecificmatcher]
== Capybara/SpecificMatcher

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 2.12
| -
|===

Checks for there is a more specific matcher offered by Capybara.

[#examples-capybaraspecificmatcher]
=== Examples

[source,ruby]
----
# bad
expect(page).to have_selector('button')
expect(page).to have_no_selector('button.cls')
expect(page).to have_css('button')
expect(page).to have_no_css('a.cls', href: 'http://example.com')
expect(page).to have_css('table.cls')
expect(page).to have_css('select')
expect(page).to have_css('input', exact_text: 'foo')

# good
expect(page).to have_button
expect(page).to have_no_button(class: 'cls')
expect(page).to have_button
expect(page).to have_no_link('foo', class: 'cls', href: 'http://example.com')
expect(page).to have_table(class: 'cls')
expect(page).to have_select
expect(page).to have_field(with: 'foo')
----

[#references-capybaraspecificmatcher]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/SpecificMatcher

[#capybaravisibilitymatcher]
== Capybara/VisibilityMatcher

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 1.39
| 2.0
|===

Checks for boolean visibility in Capybara finders.

Capybara lets you find elements that match a certain visibility using
the `:visible` option. `:visible` accepts both boolean and symbols as
values, however using booleans can have unwanted effects. `visible:
false` does not find just invisible elements, but both visible and
invisible elements. For expressiveness and clarity, use one of the
symbol values, `:all`, `:hidden` or `:visible`.
Read more in
https://www.rubydoc.info/gems/capybara/Capybara%2FNode%2FFinders:all[the documentation].

[#examples-capybaravisibilitymatcher]
=== Examples

[source,ruby]
----
# bad
expect(page).to have_selector('.foo', visible: false)
expect(page).to have_css('.foo', visible: true)
expect(page).to have_link('my link', visible: false)

# good
expect(page).to have_selector('.foo', visible: :visible)
expect(page).to have_css('.foo', visible: :all)
expect(page).to have_link('my link', visible: :hidden)
----

[#references-capybaravisibilitymatcher]
=== References

* https://www.rubydoc.info/gems/rubocop-capybara/RuboCop/Cop/Capybara/VisibilityMatcher
